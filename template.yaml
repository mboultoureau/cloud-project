heat_template_version: "2021-04-16"

description: "Projet Cloud Infra Usage"

parameters:
  network_name:
    type: string
    description: Name given to the network
    default: IAI3_10_network
  network_subnet_cidr:
    type: string
    description: CIDR of the subnetwork
    default: 10.100.0.0/24
  external_subnet:
    type: string
    description: name of the external subnetwork
    default: External-subnet
  gateway_name:
    type: string
    description: Gateway IP of the subnetwork
    default: External-ENSSAT
  router_name:
    type: string
    description: Name given to the router
    default: IAI3_10_router
  frontend_vm_name:
    type: string
    description: Name given to the frontend VM
    default: IAI3_10_frontend_vm
  frontend_ip_address:
    type: string
    description: Public IP address assigned to the frontend VM
    default: 148.60.225.226
  backend_vm_name:
    type: string
    description: Name given to the backend VM
    default: IAI3_10_backend_vm
  storage_vm_name:
    type: string
    description: Name given to the storage VM
    default: IAI3_10_storage_vm
  image:
    type: string
    description: Name or ID of image to use for servers
    default: debian12_docker
  flavor:
    type: string
    description: Name of Flavor to use for servers
    default: m1.medium

resources:
  # Network

  network:
    type: OS::Neutron::Net
    properties:
      name: { get_param: network_name }

  subnet:
    type: OS::Neutron::Subnet
    properties:
      network_id: { get_resource: network }
      cidr: { get_param: network_subnet_cidr }
      #gateway_ip: { get_param: gateway_ip } TODO

  # Router

  router_port:
    type: OS::Neutron::Port
    properties:
      network_id: { get_resource: network }
      fixed_ips:
        - subnet_id: { get_resource: subnet }

  router:
    type: OS::Neutron::Router
    properties:
      name: { get_param: router_name }
      # TODO: missing related port (gateway of subnet previously created)
      external_gateway_info:
        network: { get_param: gateway_name }

  # Interface

  interface:
    type: OS::Neutron::RouterInterface
    properties:
      router_id: { get_resource: router }
      subnet_id: { get_resource: subnet }

  # Frontend

  frontend_security_group:
    type: OS::Neutron::SecurityGroup
    properties:
      name: frontend_security_group
      rules:
        # SSL
        - direction: ingress
          protocol: tcp
          port_range_min: 22
          port_range_max: 22
        # HTTP
        - direction: ingress
          protocol: tcp
          port_range_min: 80
          port_range_max: 80
        # HTTPS
        - direction: ingress
          protocol: tcp
          port_range_min: 443
          port_range_max: 443
        # Reverse Proxy Dashboard
        - direction: ingress
          protocol: tcp
          port_range_min: 8080
          port_range_max: 8080

  frontend_port:
    type: OS::Neutron::Port
    properties:
      network_id: { get_resource: network }
      fixed_ips:
        - subnet_id: { get_resource: subnet }
      security_groups:
        - default
        - { get_resource: frontend_security_group }

  # public_frontend_port:
  #   type: OS::Neutron::Port
  #   properties:
  #     network_id: b2f07d8a-5b46-4fc8-a54e-e9cf4de8bee0
  #     fixed_ips:
  #       - subnet_id: 2e7d9dea-44e4-4ca8-bb4a-77babcbd4abb # External-ENSSAT = { get_resource: { get_param: external_subnet } } marche pas
  #         ip_address: { get_param: frontend_ip_address }
  #     security_groups:
  #       - default
  #       - { get_resource: frontend_security_group }

  frontend_keypair:
    type: OS::Nova::KeyPair
    properties:
      name: frontend_keypair
      save_private_key: true

  floating_ip_frontend:
    type: OS::Neutron::FloatingIP
    properties:
      floating_network: { get_param: gateway_name }
      # fixed_ip_address: { get_param: frontend_ip_address }
      # floating_network_id: b2f07d8a-5b46-4fc8-a54e-e9cf4de8bee0 # { get_param: gateway_name }
      # port_id: { get_resource: public_frontend_port }

  floating_ip_frontend_association:
   type: OS::Neutron::FloatingIPAssociation 
   properties:
     floatingip_id: { get_resource: floating_ip_frontend }
     port_id: { get_resource: frontend_port }

  frontend_server:
    type: OS::Nova::Server
    properties:
      name: { get_param: frontend_vm_name }
      image: { get_param: image }
      flavor: { get_param: flavor }
      key_name: { get_resource: frontend_keypair }
      networks:
        - port: { get_resource: frontend_port }
      user_data_format: RAW
      user_data:
        str_replace:
          template: |
            #cloud-config
            users:
              - name: frontend
                plain_text_passwd: password
                home: /home/frontend
                lock_passwd: false
                shell: /bin/bash
                groups: [sudo, docker]
            runcmd:
              - cd /home/frontend
              - git clone "https://github.com/mboultoureau/roland-garros"
              - chown -R frontend:frontend roland-garros
              - cd roland-garros
              - echo "FRONTEND_URL=$FRONTEND_IP_ADDRESS" > .env.file
              - docker compose --env-file ./.env.file up -d frontend reverse-proxy
            final_message: "Frontend server initialized successfully."
          params:
            $FRONTEND_IP_ADDRESS: { get_attr: [floating_ip_frontend, floating_ip_address] }

  # Backend

  backend_port:
    type: OS::Neutron::Port
    properties:
      network_id: { get_resource: network }
      fixed_ips:
        - subnet_id: { get_resource: subnet }
      security_groups:
        - default
        - { get_resource: backend_security_group }

  backend_keypair:
    type: OS::Nova::KeyPair
    properties:
      name: backend_keypair
      save_private_key: true

  backend_security_group:
    type: OS::Neutron::SecurityGroup
    properties:
      name: backend_security_group
      rules: []

  backend_server:
    type: OS::Nova::Server
    properties:
      name: { get_param: backend_vm_name }
      image: { get_param: image }
      flavor: { get_param: flavor }
      key_name: { get_resource: backend_keypair }
      networks:
        - port: { get_resource: backend_port }
      user_data_format: RAW
      user_data: |
        #cloud-config
        users:
          - name: backend
            plain_text_passwd: password
            home: /home/backend
            lock_passwd: false
            shell: /bin/bash
            groups: [sudo, docker]
        runcmd:
          - cd /home/backend
          - git clone "https://github.com/mboultoureau/roland-garros"
          - chown -R backend:backend roland-garros
          - cd roland-garros
          - docker-compose up -d backend mysql
        final_message: "Backend server initialized successfully."

  # Storage

  storage_server:
    type: OS::Cinder::Volume
    properties:
      name: { get_param: storage_vm_name }
      size: 2

  storage_attachment:
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: backend_server }
      volume_id: { get_resource: storage_server }
      mountpoint: /dev/vdb

outputs:
  frontend_ip_address:
    value: { get_attr: [floating_ip_frontend, floating_ip_address] }

  frontend_private_key:
    value: { get_attr: [frontend_keypair, private_key] }

  backend_private_key:
    value: { get_attr: [backend_keypair, private_key] }

  #floating_ip_frontend_association:
  #  value: { get_attr: [floating_ip_frontend_association, show] } # TODO: no output, fix

# TODO : fixer le pb des erreurs réseau sur la stack

# TODO tester l'adresse publique ajoutée au front

# TODO Utiliser une config séparée:
#frontend_user_data:
#	type: OS::Heat::SoftwareConfig
#	properties:
#		config: |
#			#!/bin/bash
#			cd ~/frontend
#			docker-compose -p "fgjrhj" -f path/dockercompose.yaml up -d
#			d

# user_data_format: SOFTWARE_CONFIG
# user_data: { get_resource: mon user config }
